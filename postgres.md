# PostgreSQL

PostgreSQL — это объектно-реляционная СУБД с открытым исходным кодом, известная своей надежностью, функциональностью и возможностью расширения. В этом руководстве будут рассмотрены основные концепции PostgreSQL с примерами использования.

**1. Создание базы данных и подключение**
Прежде чем начать работу, вам нужно создать базу данных и подключиться к ней.

- Пример:
  ```sql
  CREATE DATABASE company_db;
  ```
- Затем можно подключиться к этой базе данных:
  ```bash
  psql -d company_db
  ```

**2. Таблицы (Tables)**
Таблицы — это основные объекты в PostgreSQL, которые содержат данные. Каждая таблица состоит из строк (записей) и столбцов (атрибутов).

- Пример:
  Создадим таблицу employees для хранения информации о сотрудниках:
  `sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INTEGER CHECK (age >= 18),
    hire_date DATE DEFAULT CURRENT_DATE,
    department_id INTEGER,
    salary DECIMAL(10, 2)
);
`
- id — это автоинкрементное поле, которое служит первичным ключом (уникальный идентификатор для каждой записи).
- name — строка длиной до 100 символов, представляющая имя сотрудника.
- age — целочисленное поле с проверкой, что возраст должен быть не меньше 18 лет.
- hire_date — дата найма сотрудника, по умолчанию — текущая дата.
- department_id — идентификатор департамента, с которым сотрудник связан.
- salary — зарплата сотрудника, представлена как число с двумя десятичными знаками.

**3. Добавление данных (INSERT)**
Запрос INSERT INTO используется для вставки новых данных в таблицу.

- Пример:
  Добавим данные в таблицу employees:
  `sql
INSERT INTO employees (name, age, department_id, salary) VALUES ('John Doe', 30, 1, 55000.00);
`
  Если не указать значение для hire_date, по умолчанию будет использована текущая дата.

**4. Извлечение данных (SELECT)**
Запросы SELECT используются для получения данных из таблиц. Они могут включать сортировку, фильтрацию и агрегацию данных.

- Пример:
  Получим всех сотрудников с зарплатой выше 50,000:
  `sql
SELECT name, salary
FROM employees
WHERE salary > 50000;
`
  Чтобы отсортировать данные по убыванию зарплаты, можно добавить ORDER BY:
  `sql
SELECT name, salary
FROM employees
WHERE salary > 50000
ORDER BY salary DESC;
`

**5. Обновление данных (UPDATE)**
Для изменения данных в таблице используется запрос UPDATE.

- Пример:
  Повысим зарплату сотрудника с именем "John Doe" на 10%:
  `sql
UPDATE employees
SET salary = salary * 1.1
WHERE name = 'John Doe';
`

**6. Удаление данных (DELETE)**
Чтобы удалить запись из таблицы, используется запрос DELETE.

- Пример:
  Удалим всех сотрудников, чья зарплата меньше 30,000:
  `sql
DELETE FROM employees
WHERE salary < 30000;
`

**7. Связи между таблицами (Joins)**
PostgreSQL поддерживает связи между таблицами, что позволяет объединять данные из разных источников.

- Пример:
  Создадим таблицу departments для хранения информации о департаментах:
  `sql
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);
`
  Теперь можем выполнить JOIN, чтобы получить имена сотрудников вместе с их департаментами:
  `sql
SELECT e.name, d.name AS department
FROM employees e
JOIN departments d ON e.department_id = d.id;
`

**8. Индексы (Indexes)**
Индексы используются для ускорения выполнения запросов к таблице, особенно при большом объеме данных.

- Пример:
  Создадим индекс на поле name в таблице employees для ускорения поиска по именам:
  `sql
CREATE INDEX idx_employee_name ON employees(name);
`
  Теперь запросы на поиск сотрудников по имени будут выполняться быстрее.

**9. Ограничения (Constraints)**
Ограничения — это правила, которые обеспечивают целостность данных в базе данных. Основные типы ограничений:

- PRIMARY KEY — указывает на уникальный идентификатор записи.
- FOREIGN KEY — обеспечивает целостность данных при ссылках между таблицами.
- UNIQUE — гарантирует уникальность значений в столбце.
- CHECK — позволяет задать пользовательские условия для значений в столбце.

- Пример:
  Добавим ограничение CHECK для проверки, что зарплата не может быть отрицательной:
  `sql
ALTER TABLE employees
ADD CONSTRAINT check_salary CHECK (salary > 0);
`

**10. Транзакции (Transactions)**
Транзакции позволяют выполнять набор операций как одно целое. В случае ошибки все изменения можно откатить.

- Пример:
  Начнем транзакцию, добавим нового сотрудника, затем откатим изменения:

  ````sql
  BEGIN;

      INSERT INTO employees (name, age, department_id, salary)
      VALUES ('Alice', 25, 2, 45000);

      ROLLBACK;
      ```
      Из-за команды ROLLBACK изменения не будут применены к базе данных.
  ````

**11. Функции и агрегатные функции**
PostgreSQL поддерживает различные встроенные функции для работы с данными, такие как агрегатные функции для выполнения вычислений по множеству строк.

- Пример:
  Посчитаем среднюю зарплату сотрудников:
  `sql
SELECT AVG(salary) FROM employees;
`
  Посчитаем количество сотрудников в каждом департаменте:
  `sql
SELECT department_id, COUNT(*) 
FROM employees
GROUP BY department_id;
`

12. Хранимые процедуры (Stored Procedures)
    Хранимые процедуры позволяют создавать пользовательские функции, которые можно вызывать для выполнения сложных операций на сервере.

- Пример:
  Создадим хранимую процедуру для добавления нового сотрудника:
  `sql
  CREATE OR REPLACE FUNCTION add_employee(
  emp_name VARCHAR,
  emp_age INTEGER,
  emp_department_id INTEGER,
  emp_salary DECIMAL
  ) RETURNS VOID AS $$
  BEGIN
  INSERT INTO employees (name, age, department_id, salary)
  VALUES (emp_name, emp_age, emp_department_id, emp_salary);
  END;
  $$
  LANGUAGE plpgsql;
  `
  Теперь можем вызвать эту функцию:
  `sql
  SELECT add_employee('Bob', 28, 1, 47000);
  `
  $$

**13. Расширения (Extensions)**
PostgreSQL поддерживает расширения, которые добавляют дополнительную функциональность. Одним из популярных расширений является PostGIS, которое позволяет работать с географическими данными.

- Пример:
  Установим расширение pg_trgm для нечеткого поиска:
  `sql
CREATE EXTENSION pg_trgm;
`
  Теперь можно искать строки, похожие на введенное значение:
  `sql
SELECT * FROM employees
WHERE name % 'Jon';
`
  Этот запрос найдет сотрудников с именами, похожими на "Jon" (например, "John").

**14. Массивы (Arrays)**
PostgreSQL поддерживает массивы, позволяющие хранить несколько значений одного типа в одном столбце.

- Пример:
  Добавим массив телефонов для каждого сотрудника:
  `sql
ALTER TABLE employees
ADD COLUMN phones TEXT[];
`
  Теперь добавим несколько номеров телефонов для сотрудника:
  `sql
UPDATE employees
SET phones = '{"123-456-7890", "987-654-3210"}'
WHERE name = 'John Doe';
`
  Запрос на выборку сотрудников с определенным номером телефона:
  `sql
SELECT name
FROM employees
WHERE '123-456-7890' = ANY (phones);
`

**15. Репликация (Replication)**
PostgreSQL поддерживает репликацию данных, что позволяет дублировать данные между несколькими серверами для обеспечения отказоустойчивости и масштабирования.

- Мастер (Primary) сервер принимает изменения.
- Слэйв (Replica) серверы синхронизируют изменения с мастером и используются для чтения данных, разгружая основной сервер.

- Пример:
  Для настройки репликации в PostgreSQL используются такие инструменты, как pg_basebackup и конфигурационные файлы postgresql.conf и pg_hba.conf. Репликация обеспечивает доступность данных даже в случае сбоя основного сервера.

**16. Полнотекстовый поиск (Full-text search)**
PostgreSQL предоставляет средства для полнотекстового поиска, что позволяет эффективно искать данные по текстовым полям.

- Пример:
  Создадим таблицу с текстовыми данными и настроим полнотекстовый поиск:

  ````sql
  CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  title VARCHAR(200),
  body TEXT
  );

      CREATE INDEX idx_documents_tsv
      ON documents USING gin(to_tsvector('english', body));
      ```
      Теперь можно выполнить полнотекстовый поиск по ключевым словам:
      ```sql
      SELECT title
      FROM documents
      WHERE to_tsvector('english', body) @@ to_tsquery('PostgreSQL & tutorial');
      ```
  ````

---

# DevOps PostgreSQL

В контексте DevOps PostgreSQL поддерживает важные процессы, такие как бэкап (резервное копирование), восстановление (recovery) и репликация (replication) для обеспечения отказоустойчивости, восстановления данных и высокой доступности. Вот как они могут быть реализованы и интегрированы в DevOps:

**1. Резервное копирование (Backup)**
Резервное копирование данных — это ключевая задача для обеспечения надежности и безопасности данных в случае сбоя системы или утраты данных. В PostgreSQL существует несколько способов создания резервных копий, таких как логические и физические бэкапы.

**_1.1. Логическое резервное копирование_**
Логическое резервное копирование позволяет экспортировать данные в виде SQL-скриптов, которые могут быть восстановлены на другой базе данных.

Команда pg_dump используется для создания резервных копий базы данных. Пример для DevOps пайплайна, где бэкапы выполняются регулярно:

```bash
pg_dump -U postgres -h localhost mydatabase > /backups/mydatabase_backup.sql
```

Можно добавить эту команду в скрипт CI/CD или cron для регулярного создания бэкапов.

Пример интеграции в cron:

```bash
# Добавление задачи для ежедневного резервного копирования базы данных в 2:00 ночи
0 2 * * * /usr/bin/pg_dump -U postgres mydatabase > /backups/mydatabase_backup.sql
```

**_1.2. Физическое резервное копирование (pg_basebackup)_**
Физическое резервное копирование сохраняет всю файловую систему базы данных и рекомендуется для больших объемов данных или в сочетании с репликацией.

Используется команда pg_basebackup, которая создает физические бэкапы базы данных:

```bash
pg_basebackup -D /backups/mydb_basebackup -Ft -z -P -X stream -U postgres
```

- -D — директория для хранения бэкапа
- -Ft — формат архива tar
- -z — сжатие архива
- -P — индикатор прогресса
- -X stream — запись WAL логов

**_Интеграция в CI/CD:_**
В CI/CD пайплайне можно настроить задачу резервного копирования при деплое нового релиза для создания точки восстановления.
Пример конфигурации GitLab CI для создания бэкапа:

```yaml
stages:
  - backup
  - deploy

backup_database:
  stage: backup
  script:
    - pg_dump -U postgres mydatabase > /backups/mydatabase_backup.sql
  when: always

deploy_application:
  stage: deploy
  script:
    - echo "Deploying the application..."
```

**2. Восстановление (Recovery)**
Процесс восстановления данных зависит от типа бэкапа (логический или физический).

**_2.1. Восстановление логического бэкапа_**
Чтобы восстановить данные из логического бэкапа, используется команда psql:

```bash
psql -U postgres -d mydatabase < /backups/mydatabase_backup.sql
```

Это загружает SQL-скрипт обратно в базу данных. Команду можно интегрировать в процесс аварийного восстановления, который может быть вызван в случае сбоя.

**_2.2. Восстановление из физического бэкапа_**
Для восстановления физического бэкапа необходимо остановить базу данных, заменить ее данные из резервной копии и перезапустить.

Пример восстановления из физического бэкапа:

Остановить PostgreSQL:

```bash
sudo systemctl stop postgresql
```

Заменить данные базы данных содержимым физического бэкапа:

```bash
rm -rf /var/lib/postgresql/data/*
tar -xvf /backups/mydb_basebackup.tar -C /var/lib/postgresql/data
```

Запустить PostgreSQL:

```bash
sudo systemctl start postgresql
```

**3. Репликация (Replication)**
Репликация позволяет поддерживать несколько копий базы данных, что критично для обеспечения высокой доступности и отказоустойчивости. PostgreSQL поддерживает потоковую репликацию (streaming replication), которая является основным методом для DevOps.

**_3.1. Настройка основной базы данных (Primary)_**
На основной базе данных нужно включить отправку WAL (Write Ahead Logs) и настроить доступ реплицируемым базам.

Включите параметры репликации в `postgresql.conf`:

```bash
# Включаем отправку WAL логов
wal_level = replica
max_wal_senders = 3
```

В `pg_hba.conf` добавьте разрешение для подключения реплик:

```bash
# Разрешение для реплики
host replication all 192.168.1.10/32 md5
```

Перезапустите PostgreSQL:

```bash
sudo systemctl restart postgresql
```

**_3.2. Настройка реплики (Standby)_**
Используйте `pg_basebackup` для создания начальной копии данных на сервере реплики:

```bash
pg_basebackup -h primary_host -D /var/lib/postgresql/data -U replication_user -Fp -Xs -P
```

Создайте файл `recovery.conf` на сервере реплики:

```bash
standby_mode = 'on'
primary_conninfo = 'host=primary_host port=5432 user=replication_user password=replication_pass'
```

Запустите реплику:

```bash
sudo systemctl start postgresql
```

Теперь у вас настроена потоковая репликация, и данные с основного сервера будут автоматически синхронизироваться с репликой.

Пример использования в DevOps:
Внедрение потоковой репликации на PostgreSQL помогает обеспечить высокую доступность базы данных. Если основной сервер выходит из строя, реплика может быстро быть поднята как основной сервер без потери данных.
В сценарии CI/CD, реплики могут использоваться для тестирования и выполнения деплоев новых версий приложения без воздействия на основную базу данных.

**4. Мониторинг репликации и бэкапов**
DevOps инженеры могут использовать инструменты мониторинга, такие как Prometheus и Grafana, чтобы отслеживать состояние репликации и регулярное выполнение бэкапов.

Пример мониторинга:

- Использование метрик PostgreSQL для отслеживания задержек репликации и ошибок при выполнении бэкапов.
- Пример Prometheus запроса для мониторинга задержки репликации:
  `pg_replication_lag_seconds > 0`
  Это покажет, если существует задержка между основной базой и репликами.
